using System.Linq.Expressions;
using System.Reflection;
using Antlr4.Runtime.Misc;
using BlueJay.Core;
using BlueJay.UI.Component.Elements;
using BlueJay.UI.Component.Elements.Attributes;
using BlueJay.UI.Component.Nodes;
using BlueJay.UI.Component.Reactivity;
using BlueJay.Utils;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace BlueJay.UI.Component.Language
{
  /// <summary>
  /// The JayTML visitor to build out a element tree to create the node structure that will watch for changes
  /// on itself to update the UI entities in the game
  /// </summary>
  internal class JayTMLVisitor : JayTMLParserBaseVisitor<object>
  {
    /// <summary>
    /// The wrapper element for the content manager container
    /// </summary>
    private readonly IContentManagerContainer _content;

    /// <summary>
    /// The set of components that this component has access to and should use when the container with the
    /// same name as one is found
    /// </summary>
    private readonly List<Type> _components;

    /// <summary>
    /// The component instance expression to reference it in the expressions
    /// </summary>
    private readonly ParameterExpression _instanceParam;

    /// <summary>
    /// The event expression to reference it in the expressions
    /// </summary>
    private readonly ParameterExpression _eventParam;

    /// <summary>
    /// The scope expression param to reference it in the expressions
    /// </summary>
    private readonly ParameterExpression _scopeParam;

    /// <summary>
    /// The cached style type since it is one element that we could be looking up alot
    /// </summary>
    private readonly Type _styleType;

    /// <summary>
    /// The node scope this set of elements have
    /// </summary>
    private readonly NodeScope _scope;

    /// <summary>
    /// If we currently need to require the event object
    /// </summary>
    private bool _hasEventObj;

    /// <summary>
    /// Constructor meant to create a JayTML expression tree
    /// </summary>
    /// <param name="content">The content manager wrapper to load data from the content manager</param>
    /// <param name="scope">The current node scope this element tree is in</param>
    /// <param name="components">The list of components that this component has acccess to when generating elements</param>
    public JayTMLVisitor(IContentManagerContainer content, NodeScope scope, List<Type> components)
    {
      _components = components;
      _content = content;
      _scope = scope;
      _instanceParam = Expression.Parameter(typeof(UIComponent), "x");
      _eventParam = Expression.Parameter(typeof(object), "evt");
      _scopeParam = Expression.Parameter(typeof(Dictionary<string, object>), "scope");
      _styleType = typeof(Style);

      _hasEventObj = false;
    }

    /// <summary>
    /// A visitor to extract all the elements from the parser
    /// </summary>
    /// <param name="context">The document parser to extract all the elements out of</param>
    /// <returns>Will return a list of elements for the parser</returns>
    public override object VisitDocument([NotNull] JayTMLParser.DocumentContext context)
    {
      return Visit(context.root);
    }

    #region Element Helpers
    /// <summary>
    /// A visitor to handle determining the slot expression
    /// </summary>
    /// <param name="context">The slot context to extract the element out of</param>
    /// <returns>The element expression needed to export the slot from</returns>
    public override object VisitSlotElement([NotNull] JayTMLParser.SlotElementContext context)
    {
      return new UISlotElement(_scope, new List<UIElementAttribute>());
    }

    /// <summary>
    /// A visitor to handle an element with children attached to it
    /// </summary>
    /// <param name="context">The element context where the tree elements can be extracted</param>
    /// <returns>Will return the element expression generated by the tree</returns>
    public override object VisitTreeElement([NotNull] JayTMLParser.TreeElementContext context)
    {
      if (context.name.Text != context.closename.Text)
        throw new ArgumentException("Opening and closing elements should be the same");

      var attrs = new List<UIElementAttribute>();
      var children = new List<UIElement>();
      for (var i = 2; i < context.ChildCount - 4; ++i)
      {
        var child = context.GetChild(i);
        if (child is JayTMLParser.AttributeContext aChild)
        {
          var attr = Visit(aChild) as UIElementAttribute;
          if (attr == null)
            throw new ArgumentNullException("Failed to create attributes");
          attrs.Add(attr);
        }
        else if (child is JayTMLParser.ContentContext cChild)
        {
          var content = Visit(cChild) as UIElement;
          if (content == null)
            throw new ArgumentNullException("Failed to create content");
          children.Add(content);
        }
      }
      UIElement? node = null;
      var component = _components.FirstOrDefault(x => x.Name == context.name.Text);
      if (component != null)
        node = new UIComponentElement(_scope, component, attrs);
      else
        node = new UIContainerElement(context.name.Text, _scope, attrs);

      foreach (var child in children)
        child.Parent = node;
      return node;
    }

    /// <summary>
    /// A visitor to handle the basic simple element without children
    /// </summary>
    /// <param name="context">The context we need to extract the simple element out of</param>
    /// <returns>Will return the simple element meant to be used</returns>
    public override object VisitSimpleElement([NotNull] JayTMLParser.SimpleElementContext context)
    {
      var attrs = new List<UIElementAttribute>();
      for (var i = 2; i < context.ChildCount - 1; ++i)
      {
        var attr = Visit(context.GetChild(i)) as UIElementAttribute;
        if (attr == null)
          throw new ArgumentNullException("Failed to create attributes");
        attrs.Add(attr);
      }

      UIElement? node = null;
      var component = _components.FirstOrDefault(x => x.Name == context.name.Text);
      if (component != null)
        node = new UIComponentElement(_scope, component, attrs);
      else
        node = new UIContainerElement(context.name.Text, _scope, attrs);
      return node;
    }
    #endregion

    #region Content Helpers
    /// <summary>
    /// A visitor to wrap up this element as a comment and should be ignored down the line
    /// </summary>
    /// <param name="context">The current comment context</param>
    /// <returns>Will return the comment element expression</returns>
    public override object VisitCommentContent([NotNull] JayTMLParser.CommentContentContext context)
    {
      return new UICommentElement(_scope);
    }

    /// <summary>
    /// A visitor to go through the char data in between elements so that we can wrap them up nicely into
    /// a callable for to get the string to be printed
    /// </summary>
    /// <param name="context">The context where the text expression lives</param>
    /// <returns>Will return a text element</returns>
    public override object VisitChardata([NotNull] JayTMLParser.ChardataContext context)
    {
      Expression expr = Expression.Constant(string.Empty);
      var shouldConcat = false;
      var str = new List<string>();
      var reactiveProps = new List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>>();
      for (var i = 0; i < context.ChildCount; ++i)
      {
        var child = context.GetChild(i);
        if (child is JayTMLParser.ContentExpressionContext cChild)
        {
          var result = Visit(cChild) as CallbackExpression;
          if (result == null)
            throw new ArgumentNullException("Could not create content expression");

          if (shouldConcat)
          {
            var constStr = ' ' + string.Join(' ', str);
            if (str.Count > 0)
              constStr += ' ';
            var constExpression = Expression.Constant(constStr);
            expr = Expression.Add(expr, constExpression, typeof(string).GetMethod("Concat", new[] { expr.Type, constExpression.Type }));
          }
          else
            expr = Expression.Constant(string.Join(' ', str) + ' ');

          Expression cExpr = Expression.Invoke(Expression.Constant(result.Callback), _instanceParam, _eventParam, _scopeParam);
          if (cExpr.Type != typeof(string))
            cExpr = Expression.Call(cExpr, "ToString", Type.EmptyTypes);

          expr = Expression.Add(expr, cExpr, typeof(string).GetMethod("Concat", new[] { expr.Type, cExpr.Type }));
          reactiveProps.AddRange(result.ReactiveProperties);
          shouldConcat = true;
          str.Clear();
        }
        else
          str.Add(child.GetText());
      }

      if (str.Count > 0)
      {
        if (shouldConcat)
        {
          var constExpression = Expression.Constant(' ' + string.Join(' ', str));
          expr = Expression.Add(expr, constExpression, typeof(string).GetMethod("Concat", new[] { expr.Type, constExpression.Type }));
        }
        else
          expr = Expression.Constant(string.Join(' ', str));
      }

      var expression = Expression.Lambda<Func<UIComponent, object?, Dictionary<string, object>?, object>>(Expression.Convert(expr, typeof(object)), _instanceParam, _eventParam, _scopeParam).Compile();

      return new UITextElement(_scope, expression, reactiveProps);
    }

    /// <summary>
    /// A visitor to get the expression context from the context and return the built lambda function
    /// </summary>
    /// <param name="context">The context meant to extract out the expression</param>
    /// <returns>Will return the content expression lambda</returns>
    public override object VisitContentExpression([NotNull] JayTMLParser.ContentExpressionContext context)
    {
      return Visit(context.expr);
    }
    #endregion

    #region Attribute Handlers
    /// <summary>
    /// The visitor for the expression attribute for handling expressions
    /// </summary>
    /// <param name="context">The context for the expression attribute</param>
    /// <returns>Will return the expression context</returns>
    public override object VisitExprattribute([NotNull] JayTMLParser.ExprattributeContext context)
    {
      var name = context.name.Text.Substring(1, context.name.Text.Length - 3);
      var expr = Visit(context.expr) as CallbackExpression;

      if (expr == null)
        throw new ArgumentNullException("Expression could not be created in expression attribute");

      return new ExpressionAttribute(name, expr.Callback, expr.ReactiveProperties);
    }

    /// <summary>
    /// The visitor for the event attribute for handling event expressions
    /// </summary>
    /// <param name="context">The context for the basic event attribute</param>
    /// <returns>Will return the event attribute</returns>
    public override object VisitEventattribute([NotNull] JayTMLParser.EventattributeContext context)
    {
      var pair = context.name.Text.Substring(1, context.name.Text.Length - 3).Split('.');
      var name = pair != null && pair.Length > 0 ? pair[0] : string.Empty;
      var modifier = pair != null && pair.Length > 1 ? pair[1] : string.Empty;

      _hasEventObj = true;
      var expr = Visit(context.expr) as CallbackExpression;
      _hasEventObj = false;

      if (expr == null)
        throw new ArgumentNullException("Expression could not be created in expression attribute");

      return new EventAttribute(name, modifier, expr.Callback);
    }

    /// <summary>
    /// The visitor for the string attribute for the constant string expression
    /// </summary>
    /// <param name="context">The context for the basic string attribute</param>
    /// <returns>Will return the attribute for the basic string attribute</returns>
    public override object VisitStringattribute([NotNull] JayTMLParser.StringattributeContext context)
    {
      var name = context.name.Text.Substring(0, context.name.Text.Length - 2);
      return new StringAttribute(name, context.str.Text);
    }

    /// <summary>
    /// The visitor for the if attribute to help with conditional elements
    /// </summary>
    /// <param name="context">The context for the if attribute</param>
    /// <returns>Will return the attribute expression for if statements</returns>
    public override object VisitIfattribute([NotNull] JayTMLParser.IfattributeContext context)
    {
      var expr = Visit(context.expr) as CallbackExpression;
      if (expr == null)
        throw new ArgumentNullException("Expression could not be generated in if statement");
      return new IfAttribute(expr.Callback, expr.ReactiveProperties);
    }

    /// <summary>
    /// The visitor for for attribute to help with looping and creating multiple elements
    /// </summary>
    /// <param name="context">The context of the for attribute</param>
    /// <returns>Will return the for attribute</returns>
    public override object VisitForattribute([NotNull] JayTMLParser.ForattributeContext context)
    {
      var scopeIdentifier = context.scope.GetText();
      if (scopeIdentifier == null)
        throw new ArgumentNullException("Could not find the scope identifier");

      var exp = Visit(context.exp) as CallbackExpression;
      if (exp == null)
        throw new ArgumentNullException("Could not create an expression for [for attribute]");
      return new ForAttribute(scopeIdentifier.Substring(1), exp.Callback, exp.ReactiveProperties);
    }

    public override object VisitStyleattribute([NotNull] JayTMLParser.StyleattributeContext context)
    {
      var styles = Visit(context.syl) as List<StyleAttribute.StyleItem>;
      if (styles == null)
        throw new ArgumentNullException("Could not create styles");
      return new StyleAttribute(styles);
    }

    /// <summary>
    /// Helper method meant to handle reference assignments to connect to the component
    /// </summary>
    /// <param name="context">The context of the ref attribute</param>
    /// <returns>Will return the ref attribute</returns>
    public override object VisitRefattribute([NotNull] JayTMLParser.RefattributeContext context)
    {
      return new RefAttribute(context.@ref.Text);
    }

    #region For Helpers
    /// <summary>
    /// The range expression meant to generate a list of integers based on the upper and lower limits
    /// </summary>
    /// <param name="context">The range context to build out the enumeration from</param>
    /// <returns>Will return a callback expression meant to create the enumeration on the fly</returns>
    public override object VisitForRangeExpression([NotNull] JayTMLParser.ForRangeExpressionContext context)
    {
      var left = Visit(context.left) as CallbackExpression;
      var right = Visit(context.right) as CallbackExpression;

      if (left ==null)
        throw new ArgumentNullException(nameof(left));
      if (right ==null)
        throw new ArgumentNullException(nameof(right));

      var reactiveProperties = left.ReactiveProperties.Concat(right.ReactiveProperties).ToList();
      return new CallbackExpression((c, e, s) =>
      {
        var start = left.Callback(c, e, s);
        var length = right.Callback(c, e, s);

        if (start is int startNumber && length is int lengthNumber)
        {
          var result = Enumerable.Range(startNumber, lengthNumber);
          return result;
        }

        return Enumerable.Range(0, 1);
      }, reactiveProperties);
    }

    /// <summary>
    /// Gets a constant integer expression meant to quickly create range operations
    /// </summary>
    /// <param name="context">The integer expression where the text for the interger exists</param>
    /// <returns>Will return a callback expression to get the underlining parsed integer</returns>
    public override object VisitForInteger([NotNull] JayTMLParser.ForIntegerContext context)
    {
      var integer = int.Parse(context.GetText());
      return new CallbackExpression((c, e, s) => integer);
    }

    /// <summary>
    /// Generates the expression in a for context
    /// </summary>
    /// <param name="context">The for expression context to get the expression from</param>
    /// <returns>Will return a callback expression meant to be called later</returns>
    public override object VisitForExpression([NotNull] JayTMLParser.ForExpressionContext context)
    {
      return Visit(context.expr);
    }
    #endregion

    #region Style Helpers
    public override object VisitStyle([NotNull] JayTMLParser.StyleContext context)
    {
      var styles = new List<StyleAttribute.StyleItem>();
      for (var i = 0; i < context.ChildCount; i += 2)
      {
        var expression = Visit(context.GetChild(i)) as StyleAttribute.StyleItem;
        if (expression == null)
          throw new ArgumentNullException("Cannot convert the identifier result");
        styles.Add(expression);
      }
      return styles;
    }

    public override object VisitStyleExpression([NotNull] JayTMLParser.StyleExpressionContext context)
    {
      return Visit(context.scopeExpression());
    }

    public override object VisitStyleItem([NotNull] JayTMLParser.StyleItemContext context)
    {
      var name = context.name.Text;
      var type = Visit(context.alternate) as StyleAttribute.StyleItemType?;
      var result = Visit(context.GetChild(context.ChildCount - 1));
      var expression = result as CallbackExpression;
      if (expression == null)
        throw new ArgumentNullException($"Could not create the expression for {name}");

      var prop = _styleType.GetProperty(name);
      if (prop == null)
        throw new ArgumentNullException($"Style {name} does not exist as a style");

      var to = Nullable.GetUnderlyingType(prop.PropertyType);
      var callback = (UIComponent c, object? evt, Dictionary<string, object>? r) =>
      {
        if (typeof(NinePatch) == prop.PropertyType)
        {
          var assetName = expression.Callback(c, evt, r) as string;
          if (assetName == null)
            throw new ArgumentNullException(nameof(assetName));
          return new NinePatch(_content.Load<Texture2D>(assetName));
        }
        if ((to ?? prop.PropertyType).IsEnum)
        {
          var value = expression.Callback(c, evt, r);
          if (value != null && value.GetType() == typeof(string))
            return Enum.Parse(to ?? prop.PropertyType, (string)value);
          return value;
        }

        var obj = expression.Callback(c, evt, r);
        if (obj == null && to != null)
          return obj;
        return Convert.ChangeType(obj, to ?? prop.PropertyType);
      };
      return new StyleAttribute.StyleItem(name, type ?? StyleAttribute.StyleItemType.Basic, callback, expression.ReactiveProperties);
    }

    public override object VisitStyleAlternate([NotNull] JayTMLParser.StyleAlternateContext context)
    {
      switch (context.type?.Text)
      {
        case "Hover": return StyleAttribute.StyleItemType.Hover;
        default: return StyleAttribute.StyleItemType.Basic;
      }
    }

    #region Value Helpers
    public override object VisitStyleDecimal([NotNull] JayTMLParser.StyleDecimalContext context)
    {
      if (float.TryParse(context.GetText(), out var dec))
        return new CallbackExpression((c, e, r) => dec);
      throw new ArgumentNullException("Could not parse decimal in style");
    }

    public override object VisitStyleInteger([NotNull] JayTMLParser.StyleIntegerContext context)
    {
      if (int.TryParse(context.GetText(), out var integer))
        return new CallbackExpression((c, e, r) => integer);
      throw new ArgumentNullException("Could not parse interger in style");
    }

    public override object VisitStyleColor([NotNull] JayTMLParser.StyleColorContext context)
    {
      var r = Visit(context.r) as CallbackExpression;
      var g = Visit(context.g) as CallbackExpression;
      var b = Visit(context.b) as CallbackExpression;

      if (r == null)
        throw new ArgumentNullException("Could not create r on color");
      if (g == null)
        throw new ArgumentNullException("Could not create g on color");
      if (b == null)
        throw new ArgumentNullException("Could not create b on color");

      var reactive = r.ReactiveProperties
        .Concat(g.ReactiveProperties)
        .Concat(b.ReactiveProperties)
        .ToList();
      var a = (UIComponent c, object? e, Dictionary<string, object>? r) => (object)255;
      if (context.a != null)
      {
        var aContext = Visit(context.a) as CallbackExpression;
        if (aContext == null)
          throw new ArgumentNullException("Could not create a on color");
        a = aContext.Callback;
        reactive = reactive.Concat(aContext.ReactiveProperties).ToList();
      }
      return new CallbackExpression((c, e, _) => new Color((int)r.Callback(c, e, _), (int)g.Callback(c, e, _), (int)b.Callback(c, e, _), (int)a(c, e, _)), reactive);
    }

    public override object VisitStylePoint([NotNull] JayTMLParser.StylePointContext context)
    {
      var x = Visit(context.x) as CallbackExpression;
      if (x == null)
        throw new ArgumentNullException("Could not create x on point");

      var reactive = x.ReactiveProperties;
      var y = x;
      if (context.y != null)
      {
        y = Visit(context.y) as CallbackExpression;
        if (y == null)
          throw new ArgumentNullException("Could not create y on point");
        reactive = reactive.Concat(y.ReactiveProperties).ToList();
      }
      return new CallbackExpression((c, e, r) => new Point((int)x.Callback(c, e, r), (int)y.Callback(c, e, r)), reactive);
    }

    public override object VisitStyleWord([NotNull] JayTMLParser.StyleWordContext context)
    {
      var txt = context.GetText();
      return new CallbackExpression((c, e, r) => txt);
    }
    #endregion
    #endregion
    #endregion

    #region Expression Handlers
    /// <summary>
    /// The visitor to wrap up the scoped expression and send the callback function back to the calling visitor
    /// </summary>
    /// <param name="context">The current context where the string expression lives</param>
    /// <returns>Will return the lambda function to be called to calculate internals</returns>
    public override object VisitScopeExpression([NotNull] JayTMLParser.ScopeExpressionContext context)
    {
      var body = Visit(context.GetChild(0)) as JayExpression;
      if (body == null)
        throw new NullReferenceException("body could not be generated");

      var expression = Expression.Lambda<Func<UIComponent, object?, Dictionary<string, object>?, object>>(Expression.Convert(body.Expression, typeof(object)), _instanceParam, _eventParam, _scopeParam).Compile();
      return new CallbackExpression(expression, body.ReactiveProperties);
    }

    #region String Expressions
    /// <summary>
    /// Visitor is meant to handle the basics of a string and concat all the other processes for the string into
    /// one string that should be used
    /// </summary>
    /// <param name="context">The current context where the string expression lives</param>
    /// <returns>Will return and expression for the string that should be processed further</returns>
    public override object VisitStringExpression([NotNull] JayTMLParser.StringExpressionContext context)
    {
      Expression expr = Expression.Constant(string.Empty);
      var reactiveProps = new List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>>();
      for (var i = 1; i < context.ChildCount - 1; ++i)
      {
        var item = Visit(context.GetChild(i)) as JayExpression;
        if (item == null)
          throw new ArgumentNullException("Could not concatenate string in expression");

        expr = Expression.Add(expr, item.Expression, typeof(string).GetMethod("Concat", new[] { expr.Type, item.Expression.Type }));
        reactiveProps.AddRange(item.ReactiveProperties);
      }
      return new JayExpression(expr, reactiveProps);
    }
    
    /// <summary>
    /// Visitor is meant to handle the static escaped string characters that could be escaped inside a string
    /// </summary>
    /// <param name="context">The current escaped string values</param>
    /// <returns>Will return an expression for the esacped character</returns>
    public override object VisitStringEscapeExpression([NotNull] JayTMLParser.StringEscapeExpressionContext context)
    {
      return new JayExpression(Expression.Constant(context.escape.Text.Substring(1)), new List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>>());
    }

    /// <summary>
    /// Visitor is meant to handle the basic string details and treat them as a basic string of what was typed
    /// </summary>
    /// <param name="context">The context for the static string</param>
    /// <returns>Will return an expression of the string being processed</returns>
    public override object VisitStringDetailsExpression([NotNull] JayTMLParser.StringDetailsExpressionContext context)
    {
      return new JayExpression(Expression.Constant(context.details.Text), new List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>>());
    }

    /// <summary>
    /// Visitor meant to handle an interp string that is meant to handle creating dynamic string easier
    /// </summary>
    /// <param name="context">The expression that should be processed into a string</param>
    /// <returns>Will return an expression that converts itself into a string</returns>
    public override object VisitStringInterpExpression([NotNull] JayTMLParser.StringInterpExpressionContext context)
    {
      var result = Visit(context.expr) as JayExpression;
      if (result == null)
        throw new ArgumentNullException("expr could not be generated for string");

      var expr = result.Expression;
      if (expr.Type != typeof(string))
        expr = Expression.Call(expr, "ToString", Type.EmptyTypes);

      return new JayExpression(expr, result.ReactiveProperties);
    }
    #endregion

    #region Mathimatical Expressions
    /// <summary>
    /// Visitor method to handle the parent expression to better represent what should be grouped with each other
    /// </summary>
    /// <param name="context">The current context being processed for the paren expression</param>
    /// <returns>Will return the paren expression for further processing</returns>
    public override object VisitParenExpression([NotNull] JayTMLParser.ParenExpressionContext context)
    {
      return Visit(context.expr);
    }

    /// <summary>
    /// Visitor is meant to handle arithmetic expressions and try to convert that expressions over to the correct
    /// types to handle a little of loosely typed expressions
    /// </summary>
    /// <param name="context">Arithmetic expression context to handle processing the left/right</param>
    /// <returns>Will return an arithmetic expression meant for further processing</returns>
    public override object VisitArithmeticExpression([NotNull] JayTMLParser.ArithmeticExpressionContext context)
    {
      var left = Visit(context.left) as JayExpression;
      var right = Visit(context.right) as JayExpression;
      if (left == null)
        throw new ArgumentNullException("Could not create left in arithmetic expression");
      if (right == null)
        throw new ArgumentNullException("Could not create right in arithmetic expression");

      var leftExpression = left.Expression;
      var rightExpression = right.Expression;
      if (leftExpression.Type == typeof(object) && rightExpression.Type == typeof(object))
        throw new ArgumentException("both left and right are type of object and cannot be used for arithmetic operations");

      // Convert one object over to the other type
      else if (leftExpression.Type == typeof(object))
        leftExpression = Expression.Convert(leftExpression, rightExpression.Type);
      else if (rightExpression.Type == typeof(object))
        rightExpression = Expression.Convert(rightExpression, leftExpression.Type);

      // Convert the objects over to string objects
      if (leftExpression.Type == typeof(string) && rightExpression.Type != typeof(string))
        rightExpression = Expression.Call(rightExpression, "ToString", Type.EmptyTypes);
      if (rightExpression.Type == typeof(string) && leftExpression.Type != typeof(string))
        leftExpression = Expression.Call(leftExpression, "ToString", Type.EmptyTypes);

      Expression? exp = null;
      switch (context.op.Start.Type)
      {
        case JayTMLLexer.PLUS:
          if (leftExpression.Type == typeof(string) && rightExpression.Type == typeof(string))
            exp = Expression.Add(leftExpression, rightExpression, typeof(string).GetMethod("Concat", new[] { leftExpression.Type, rightExpression.Type }));
          else
            exp = Expression.Add(leftExpression, rightExpression);
          break;
        case JayTMLLexer.MINUS:
          exp = Expression.Subtract(leftExpression, rightExpression);
          break;
        case JayTMLLexer.TIMES:
          exp = Expression.Multiply(leftExpression, rightExpression);
          break;
        case JayTMLLexer.DIVIDE:
          exp = Expression.Divide(leftExpression, rightExpression);
          break;
        case JayTMLLexer.MOD:
          exp = Expression.Modulo(leftExpression, rightExpression);
          break;
      }

      if (exp == null)
        throw new ArgumentNullException("Could not create exp in arithmetic expression");
      return new JayExpression(exp, left.ReactiveProperties.Concat(right.ReactiveProperties).ToList());
    }

    /// <summary>
    /// Visitor meant to handle comparator expression for basic boolean logic
    /// </summary>
    /// <param name="context">The comparator conext that should be parsed</param>
    /// <returns>Will create a comparator expression for further processing</returns>
    public override object VisitComparatorExpression([NotNull] JayTMLParser.ComparatorExpressionContext context)
    {
      var left = Visit(context.left) as JayExpression;
      var right = Visit(context.right) as JayExpression;

      if (left == null)
        throw new ArgumentNullException("Could not create the left for a comparator expression");
      if (right == null)
        throw new ArgumentNullException("Could not create the right for a comparator expression");

      var leftExpression = left.Expression;
      var rightExpression = right.Expression;

      Expression? exp = null;
      switch (context.op.Start.Type)
      {
        case JayTMLLexer.GT:
          exp = Expression.GreaterThan(leftExpression, rightExpression);
          break;
        case JayTMLLexer.GTE:
          exp = Expression.GreaterThanOrEqual(leftExpression, rightExpression);
          break;
        case JayTMLLexer.LT:
          exp = Expression.LessThan(leftExpression, rightExpression);
          break;
        case JayTMLLexer.LTE:
          exp = Expression.LessThanOrEqual(leftExpression, rightExpression);
          break;
        case JayTMLLexer.EQ:
          exp = Expression.Equal(leftExpression, rightExpression);
          break;
      }

      if (exp == null)
        throw new ArgumentNullException("Could not create expression for comparitor");
      return new JayExpression(exp, left.ReactiveProperties.Concat(right.ReactiveProperties).ToList());
    }

    /// <summary>
    /// Visitor meant to handle binary expressions first a foremost, everything will go through this expression
    /// so that all processing can happen correctly
    /// </summary>
    /// <param name="context">The binary expression</param>
    /// <returns>Returns a processed binary expression for further processing</returns>
    public override object VisitBinaryExpression([NotNull] JayTMLParser.BinaryExpressionContext context)
    {
      var left = Visit(context.left) as JayExpression;
      if (left == null)
        throw new ArgumentNullException("Could not create left in binary expression");

      if (context.right == null)
        return left;

      var right = Visit(context.right) as JayExpression;
      if (right == null)
        throw new ArgumentNullException("Could not create a right in binary expression");

      var leftExpression = left.Expression;
      var rightExpression = right.Expression;

      Expression? exp = null;
      switch (context.op.Start.Type)
      {
        case JayTMLLexer.AND:
          exp = Expression.And(leftExpression, rightExpression);
          break;
        case JayTMLLexer.OR:
          exp = Expression.Or(leftExpression, rightExpression);
          break;
      }

      if (exp == null)
        throw new ArgumentNullException("Could not create an expression in binary expression");
      return new JayExpression(exp, left.ReactiveProperties.Concat(right.ReactiveProperties).ToList());
    }

    /// <summary>
    /// Visitor to handle the not expression
    /// </summary>
    /// <param name="context">The not expression context that should be parsed and processed</param>
    /// <returns>Will return the not expression meant for further processing</returns>
    public override object VisitNotExpression([NotNull] JayTMLParser.NotExpressionContext context)
    {
      var result = Visit(context.expr) as JayExpression;
      if (result == null)
        throw new ArgumentNullException("Could not create not expression");
      return new JayExpression(Expression.Not(result.Expression), result.ReactiveProperties);
    }
    #endregion

    #region Identifier Expressions
    /// <summary>
    /// Visitor method to handle processing the identifier and handling what this expression should be watching for changes on
    /// </summary>
    /// <param name="context">The identifier expression meant for processing the path of where the data exists</param>
    /// <returns>Will return an invocation of a property in the scope or on the context of the component this is bound to</returns>
    public override object VisitIdentifierExpression([NotNull] JayTMLParser.IdentifierExpressionContext context)
    {
      Expression expr = Expression.Convert(_instanceParam, _scope.ComponentType);
      for (var i = 0; i < context.ChildCount; ++i)
      {
        var identifier = Visit(context.GetChild(i)) as IdentifierResult;
        if (identifier == null)
          throw new ArgumentNullException("Could not create identifier path");

        if (typeof(IReactiveProperty).IsAssignableFrom(expr.Type))
          expr = Expression.PropertyOrField(expr, "Value");

        expr = Expression.PropertyOrField(expr, identifier.Name);

        if (identifier.Callback != null)
        {
          var invoke = Expression.Invoke(Expression.Constant(identifier.Callback), _instanceParam, _eventParam, _scopeParam);
          expr = Expression.Property(expr, "Item", Expression.Convert(invoke, typeof(int)));
        }
      }

      var reactiveProps = new List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>>();
      if (typeof(IReactiveProperty).IsAssignableFrom(expr.Type))
      {
        var expression = Expression.Lambda<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty>>(Expression.Convert(expr, typeof(IReactiveProperty)), _instanceParam, _eventParam, _scopeParam).Compile();
        reactiveProps.Add(expression);
        expr = Expression.PropertyOrField(expr, "Value");
      }

      return new JayExpression(expr, reactiveProps);
    }

    /// <summary>
    /// Visitor is meant to process event identifier expressions and use the event object passed in as a parameter
    /// </summary>
    /// <param name="context">The current context of the invoking method</param>
    /// <returns>Will return the expression to get the event paramter</returns>
    public override object VisitEventIdentifierExpression([NotNull] JayTMLParser.EventIdentifierExpressionContext context)
    {
      if (!_hasEventObj)
        throw new ArgumentException("Cannot access event object if not in context of event");
      return new JayExpression(_eventParam, new List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>>());
    }

    /// <summary>
    /// Visitor is meant to process the scope identifier and use the scope instead of the current component parameter
    /// </summary>
    /// <param name="context">The current context of the invoking method</param>
    /// <returns>Will return an identifier result</returns>
    public override object VisitScopeIdentifierExpression([NotNull] JayTMLParser.ScopeIdentifierExpressionContext context)
    {
      var str = context.GetText();

      var path = new List<string>();
      for (var i = 3; i < context.ChildCount; i += 2)
        path.Add(context.GetChild(i).GetText());

      var scopeItem = Expression.Property(_scopeParam, "Item", Expression.Constant(context.identifier.Text));
      var listConstant = Expression.Constant(path);

      var method = typeof(Utils).GetMethod(nameof(Utils.GetValue), BindingFlags.Public | BindingFlags.Static);
      if (method == null)
        throw new ArgumentNullException("Method not found");
      return new JayExpression(Expression.Call(null, method, scopeItem, listConstant), new List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>>());
    }

    /// <summary>
    /// Visitor meant to access the identifier based on the dot
    /// </summary>
    /// <param name="context">The current context of the invoking method</param>
    /// <returns>Will return an identifier result</returns>
    public override object VisitSimpleIdentifier([NotNull] JayTMLParser.SimpleIdentifierContext context)
    {
      return new IdentifierResult(context.id.Text);
    }

    /// <summary>
    /// Visitor meant to access the identifier based on the dot
    /// </summary>
    /// <param name="context">The current context of the invoking method</param>
    /// <returns>Will return an identifier result</returns>
    public override object VisitDotIdentifier([NotNull] JayTMLParser.DotIdentifierContext context)
    {
      return new IdentifierResult(context.id.Text);
    }

    /// <summary>
    /// Visitor meant to access the array identifier and get a callback to calculate the index for the array
    /// </summary>
    /// <param name="context">The current context of the invoking method</param>
    /// <returns>Will return an identifier result</returns>
    public override object VisitArrayIdentifier([NotNull] JayTMLParser.ArrayIdentifierContext context)
    {
      var expr = Visit(context.expr) as CallbackExpression;
      if (expr == null)
        throw new ArgumentNullException("Could not create a simple array expression");
      return new IdentifierResult(context.id.Text, expr.Callback, expr.ReactiveProperties);
    }

    /// <summary>
    /// Visitor meant to access the array identifier and get a callback to calculate the index for the array
    /// </summary>
    /// <param name="context">The current context of the invoking method</param>
    /// <returns>Will return an identifier result</returns>
    public override object VisitSimpleArrayIdentifier([NotNull] JayTMLParser.SimpleArrayIdentifierContext context)
    {
      var expr = Visit(context.expr) as CallbackExpression;
      if (expr == null)
        throw new ArgumentNullException("Could not create a simple array expression");
      return new IdentifierResult(context.id.Text, expr.Callback, expr.ReactiveProperties);
    }

    /// <summary>
    /// Visitor is meant to process a invoking method and translates it to what needs to be called and what conversions need to happen to
    /// get that working properly
    /// </summary>
    /// <param name="context">The current context of the invoking method</param>
    /// <returns>Will return in invocation method expression for further processing</returns>
    public override object VisitInvokeMethodExpression([NotNull] JayTMLParser.InvokeMethodExpressionContext context)
    {
      var method = _scope.ComponentType.GetMethod(context.method.Text);
      if (method == null)
        throw new ArgumentNullException("Could not found method on type given");

      var args = new List<Expression>();
      var reactiveProps = new List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>>();
      if (context.ChildCount > 3)
      { // Only handle arguments if we have more children then 3
        for (var i = 2; i < context.ChildCount; i += 2)
        {
          var builderExpr = Visit(context.GetChild(i)) as JayExpression;
          if (builderExpr == null)
            throw new ArgumentNullException("Could not create argument expression");

          var expr = builderExpr.Expression;
          if (expr.Type == typeof(object))
            expr = Expression.Convert(expr, method.GetParameters()[args.Count].ParameterType);
          args.Add(expr);
          reactiveProps.AddRange(builderExpr.ReactiveProperties);
        }
      }

      return new JayExpression(Expression.Call(Expression.Convert(_instanceParam, _scope.ComponentType), method, args), reactiveProps);
    }
    #endregion

    #region Static Expression
    /// <summary>
    /// Visitor to handle parsing the numeric expression, this could be an integer expression or a floating expression
    /// </summary>
    /// <param name="context">The context for the numeric expression</param>
    /// <returns>Will return a numeric expression for further processing</returns>
    public override object VisitNumericExpression([NotNull] JayTMLParser.NumericExpressionContext context)
    {
      if (int.TryParse(context.num.Text, out var numInt))
        return new JayExpression(Expression.Constant(numInt), new List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>>());
      if (float.TryParse(context.num.Text, out var numFloat))
        return new JayExpression(Expression.Constant(numFloat), new List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>>());
      throw new ArgumentOutOfRangeException("Could not create numeric expression because the we are not dealing with a number");
    }

    /// <summary>
    /// Visitor to handle the boolean expression
    /// </summary>
    /// <param name="context">The context for the boolean expression</param>
    /// <returns>Will return a boolean expression for further processing</returns>
    public override object VisitBoolExpression([NotNull] JayTMLParser.BoolExpressionContext context)
    {
      if (bool.TryParse(context.expr.GetText(), out var val))
        return new JayExpression(Expression.Constant(val), new List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>>());
      throw new ArgumentOutOfRangeException("Could not create a bool expression since a bool could not be parsed");
    }
    #endregion
    #endregion

    #region Internal Class Definitions
    /// <summary>
    /// The jay expression meant to store a slice of a callback function that will be used to build it out
    /// </summary>
    private class JayExpression
    {
      /// <summary>
      /// The expression object that is currently being constructed
      /// </summary>
      public Expression Expression { get; }

      /// <summary>
      /// The reactive properties found while generating the previous expression
      /// </summary>
      public List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>> ReactiveProperties { get; }

      /// <summary>
      /// Constructor meant to return a expression object to watch for reactive properties and the section of the expression
      /// </summary>
      /// <param name="expression">The expression object that is currently being constructed</param>
      /// <param name="reactiveProperties">The reactive properties found while generating the previous expression</param>
      public JayExpression(Expression expression, List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>> reactiveProperties)
      {
        Expression = expression;
        ReactiveProperties = reactiveProperties;
      }
    }

    /// <summary>
    /// The callback expression that could have a bunch of different expressions all wrapped up into one
    /// </summary>
    private class CallbackExpression
    {
      /// <summary>
      /// The callback expression to get the underlining object
      /// </summary>
      public Func<UIComponent, object?, Dictionary<string, object>?, object> Callback { get; }

      /// <summary>
      /// The reactive properties that were found while creating the callback function
      /// </summary>
      public List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>> ReactiveProperties { get; }

      /// <summary>
      /// Constructor meant to create the callback expression
      /// </summary>
      /// <param name="callback">The callback expression to get the underlining object</param>
      /// <param name="reactiveProperties">The reactive properties that were found while creating the callback function</param>
      public CallbackExpression(Func<UIComponent, object?, Dictionary<string, object>?, object> callback, List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>>? reactiveProperties = null)
      {
        Callback = callback;
        ReactiveProperties = reactiveProperties ?? new List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>>();
      }
    }

    /// <summary>
    /// Identifier result meant to be a representation of something on the component we are accessing
    /// </summary>
    private class IdentifierResult
    {
      /// <summary>
      /// The current name that this identifier result is attached too
      /// </summary>
      public string Name { get; }

      /// <summary>
      /// The callback method meant to be used when getting the identifier result
      /// </summary>
      public Func<UIComponent, object?, Dictionary<string, object>?, object>? Callback { get; }

      /// <summary>
      /// The reactive properties that were found along the way to create the callback
      /// </summary>
      public List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>> ReactiveProperties { get; }

      /// <summary>
      /// Constructor for the identifier result
      /// </summary>
      /// <param name="name">The current name that this identifier result is attached too</param>
      /// <param name="callback">The callback method meant to be used when getting the identifier result</param>
      /// <param name="reactiveProperties">The reactive properties that were found along the way to create the callback</param>
      public IdentifierResult(string name, Func<UIComponent, object?, Dictionary<string, object>?, object>? callback = null, List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>>? reactiveProperties = null)
      {
        Name = name;
        Callback = callback;
        ReactiveProperties = reactiveProperties ?? new List<Func<UIComponent, object?, Dictionary<string, object>?, IReactiveProperty?>>();
      }
    }
    #endregion
  }
}
